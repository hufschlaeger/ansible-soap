# --- Variablen (k√∂nnen global in gitlab-ci.yml √ºberschrieben werden) ---
variables:
  PYTHON_VERSION: "3.11"
  DOCKER_IMAGE: "python:3.11-slim"

# --- Jobs ---
test-external-services:
  stage: nightly-test
  image: $DOCKER_IMAGE
  tags: [docker]
  before_script:
    - python -V
    - pip install virtualenv
    - virtualenv venv
    - source venv/bin/activate
    - pip install --upgrade pip
  script:
    - pip install ansible-core
    - pip install -r requirements.txt
    - |
      # Collection bauen und installieren
      ansible-galaxy collection build --force
      ansible-galaxy collection install *.tar.gz --force
    - |
      # Alle externen Services testen
      echo "üåô Testing all example playbooks against live services (Nightly Run)..."
      mkdir -p test-reports

      # Validation Tests
      for playbook in playbooks/examples/validate/*.yml; do
        if [ -f "$playbook" ]; then
          echo "üß™ Testing: $playbook"
          ansible-playbook "$playbook" -v > "test-reports/$(basename $playbook .yml).log" 2>&1 || echo "‚ö† Warning: $playbook failed (external service issue?)" >> test-reports/failed-tests.txt
        fi
      done

      # Request Tests
      for playbook in playbooks/examples/request/*.yml; do
        if [ -f "$playbook" ]; then
          echo "üß™ Testing: $playbook"
          ansible-playbook "$playbook" -v > "test-reports/$(basename $playbook .yml).log" 2>&1 || echo "‚ö† Warning: $playbook failed (external service issue?)" >> test-reports/failed-tests.txt
        fi
      done
    - |
      # Test-Report generieren
      echo "# üåô Nightly Test Report - $(date)" > test-report.md
      echo "" >> test-report.md
      echo "## ‚úÖ Successfully tested playbooks" >> test-report.md
      ls -1 playbooks/examples/validate/*.yml playbooks/examples/request/*.yml | sed 's/^/  - /' >> test-report.md
      echo "" >> test-report.md
      echo "## ‚ö† Failed tests (if any)" >> test-report.md
      if [ -f test-reports/failed-tests.txt ]; then
        cat test-reports/failed-tests.txt >> test-report.md
      else
        echo "  - No failures detected!" >> test-report.md
      fi
  artifacts:
    when: always
    paths:
      - test-reports/
      - test-report.md
    expire_in: 7 days
  rules:
    - if: '$CI_PIPELINE_SOURCE == "schedule"'  # Geplant (Cron)
    - if: '$CI_PIPELINE_SOURCE == "web"'       # Manuell gestartet

health-check:
  stage: nightly-test
  image: $DOCKER_IMAGE
  tags: [docker]
  before_script:
    - python -V
    - pip install virtualenv
    - virtualenv venv
    - source venv/bin/activate
    - pip install --upgrade pip
    - pip install mistune requests pyline
  script:
    - |
      # Markdown-Link-Check (ersetzt das GitHub-Action-√Ñquivalent)
      python .gitlab/helpers/check_links.py
    - |
      echo "üîç Running Pylint on module_utils..."
      pylint plugins/module_utils/soap_module/ --disable=C,R --output-format=text > pylint-report.txt || true
      echo "Pylint completed (warnings are non-blocking)."
  artifacts:
    when: always
    paths:
      - broken-links.md
      - pylint-report.txt
    expire_in: 7 days
  rules:
    - if: '$CI_PIPELINE_SOURCE == "schedule"'  # Geplant (Cron)
    - if: '$CI_PIPELINE_SOURCE == "web"'       # Manuell gestartet

notify-gotify:
  stage: nightly-test
  image: alpine:latest  # Leichtgewichtiges Image mit curl
  tags: [docker]
  needs: ["test-external-services", "health-check"]
  before_script:
    - apk add --no-cache curl jq  # jq f√ºr JSON-Verarbeitung (optional)
  script:
    - |
      # Gotify-Nachricht basierend auf den Job-Ergebnissen
      if [ -f "test-reports/failed-tests.txt" ] && [ -s "test-reports/failed-tests.txt" ]; then
        # ‚ùå Es gab Fehler
        MESSAGE="üö® *Nightly Tests FAILED* (${CI_COMMIT_SHORT_SHA})
        ‚û° <${CI_PIPELINE_URL}|View Pipeline>
        ‚û° <${CI_PROJECT_URL}/-/jobs/${CI_JOB_ID}/artifacts/file/test-report.md|Test Report>
        ‚û° <${CI_PROJECT_URL}/-/jobs/${CI_JOB_ID}/artifacts/file/broken-links.md|Broken Links>
        ‚û° *Failed Tests*: $(cat test-reports/failed-tests.txt | wc -l)"
        PRIORITY=5  # Hoch (5 = kritisch)
      else
        # ‚úÖ Alle Tests erfolgreich
        MESSAGE="‚úÖ *Nightly Tests PASSED* (${CI_COMMIT_SHORT_SHA})
        ‚û° <${CI_PIPELINE_URL}|View Pipeline>
        ‚û° <${CI_PROJECT_URL}/-/jobs/${CI_JOB_ID}/artifacts/file/test-report.md|Test Report>"
        PRIORITY=1  # Niedrig (1 = informativ)
      fi

      # Gotify-API aufrufen
      curl \
        -X POST \
        -H "Content-Type: application/json" \
        -H "X-Gotify-Key: ${GOTIFY_APP_TOKEN}" \
        -d "{
          \"message\": \"${MESSAGE}\",
          \"priority\": ${PRIORITY},
          \"title\": \"üåô Nightly Tests: ${CI_PROJECT_NAME}\",
          \"extras\": {
            \"client::display\": {
              \"contentType\": \"text/markdown\"
            },
            \"client::notification\": {
              \"click\": {
                \"url\": \"${CI_PIPELINE_URL}\"
              }
            }
          }
        }" \
        "${GOTIFY_URL}/message?token=${GOTIFY_APP_TOKEN}"

      echo "Gotify notification sent!"
  rules:
    - if: '$CI_PIPELINE_SOURCE == "schedule"'  # Nur bei geplanten Nightly-L√§ufen
    - if: '$CI_PIPELINE_SOURCE == "web"'       # Optional: Auch bei manuellem Trigger
  variables:
    GOTIFY_URL: "https://notify.hufschlaeger.net"  # CI/CD-Variable √ºberschreibt dies
    GOTIFY_APP_TOKEN: "$GOTIFY_APP_TOKEN"          # Wird aus GitLab-Variablen geladen
