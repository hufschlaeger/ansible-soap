# --- Variablen (k√∂nnen global in gitlab-ci.yml √ºberschrieben werden) ---
variables:
  PYTHON_VERSION: "3.11"
  DOCKER_IMAGE: "python:3.11-slim"

# --- Jobs ---
test-external-services:
  stage: nightly-test
  image: $DOCKER_IMAGE
  tags: [docker]
  before_script:
    - python -V
    - pip install virtualenv
    - virtualenv venv
    - source venv/bin/activate
    - pip install --upgrade pip
  script:
    - pip install ansible-core
    - pip install -r requirements.txt
    - |
      # Collection bauen und installieren
      ansible-galaxy collection build --force
      ansible-galaxy collection install *.tar.gz --force
    - |
      # Alle externen Services testen
      echo "üåô Testing all example playbooks against live services (Nightly Run)..."
      mkdir -p test-reports

      # Validation Tests
      for playbook in playbooks/examples/validation/*.yml; do
        if [ -f "$playbook" ]; then
          echo "üß™ Testing: $playbook"
          ansible-playbook "$playbook" -v > "test-reports/$(basename $playbook .yml).log" 2>&1 || echo "‚ö† Warning: $playbook failed (external service issue?)" >> test-reports/failed-tests.txt
        fi
      done

      # Request Tests
      for playbook in playbooks/examples/request/*.yml; do
        if [ -f "$playbook" ]; then
          echo "üß™ Testing: $playbook"
          ansible-playbook "$playbook" -v > "test-reports/$(basename $playbook .yml).log" 2>&1 || echo "‚ö† Warning: $playbook failed (external service issue?)" >> test-reports/failed-tests.txt
        fi
      done
    - |
      # Test-Report generieren
      echo "# üåô Nightly Test Report - $(date)" > test-report.md
      echo "" >> test-report.md
      echo "## ‚úÖ Successfully tested playbooks" >> test-report.md
      ls -1 playbooks/examples/validation/*.yml playbooks/examples/request/*.yml | sed 's/^/  - /' >> test-report.md
      echo "" >> test-report.md
      echo "## ‚ö† Failed tests (if any)" >> test-report.md
      if [ -f test-reports/failed-tests.txt ]; then
        cat test-reports/failed-tests.txt >> test-report.md
      else
        echo "  - No failures detected!" >> test-report.md
      fi
  artifacts:
    when: always
    paths:
      - test-reports/
      - test-report.md
    expire_in: 7 days
  rules:
    - if: '$CI_PIPELINE_SOURCE == "schedule"'  # Geplant (Cron)
    - if: '$CI_PIPELINE_SOURCE == "web"'       # Manuell gestartet

health-check:
  stage: nightly-test
  image: $DOCKER_IMAGE
  tags: [docker]
  before_script:
    - python -V
    - pip install virtualenv
    - virtualenv venv
    - source venv/bin/activate
    - pip install --upgrade pip
  script:
    - |
      # Markdown-Link-Check (ersetzt das GitHub-Action-√Ñquivalent)
      pip install mistune requests
      python - <<EOF
      import re
      import requests
      from urllib.parse import urlparse
      import mistune  # Updated for mistune>=3.0.0
      
      class LinkExtractor(mistune.BaseRenderer):  # Changed from ASTRenderer to BaseRenderer
          def __init__(self):
              self.links = []
      
          def link(self, link, title=None, text=None):
              self.links.append({"url": link, "text": text})
      
      # README.md pr√ºfen
      with open("README.md", "r") as f:
          content = f.read()
      
      # Extract links using mistune
      renderer = LinkExtractor()
      markdown = mistune.create_markdown(renderer=renderer)
      markdown(content)
      links = renderer.links
      
      broken_links = []
      
      for link in links:
          url = link["url"]
          if url.startswith(("http://", "https://")):
              try:
                  response = requests.head(url, allow_redirects=True, timeout=10)
                  if response.status_code >= 400:
                      broken_links.append(f"- ‚ùå {url} (Status: {response.status_code})")
                  else:
                      print(f"‚úÖ {url} (OK)")
              except Exception as e:
                  broken_links.append(f"- ‚ùå {url} (Error: {str(e)})")
      
      if broken_links:
          print("\nüîó Broken links found:")
          for link in broken_links:
              print(link)
          with open("broken-links.md", "w") as f:
              f.write("# Broken Links Report\n\n")
              f.write("\n".join(broken_links))
      else:
          print("\n‚úÖ All links are working!")
          with open("broken-links.md", "w") as f:
              f.write("# All links are working! üéâ")
      EOF
    - |
      # Pylint f√ºr Code-Qualit√§t
      pip install pylint
      echo "üîç Running Pylint on module_utils..."
      pylint plugins/module_utils/soap_module/ --disable=C,R --output-format=text > pylint-report.txt || true
      echo "Pylint completed (warnings are non-blocking)."
  artifacts:
    when: always
    paths:
      - broken-links.md
      - pylint-report.txt
    expire_in: 7 days
  rules:
    - if: '$CI_PIPELINE_SOURCE == "schedule"'  # Geplant (Cron)
    - if: '$CI_PIPELINE_SOURCE == "web"'       # Manuell gestartet

notify-gotify:
  stage: nightly-test
  image: alpine:latest  # Leichtgewichtiges Image mit curl
  tags: [docker]
  needs: ["test-external-services", "health-check"]
  before_script:
    - apk add --no-cache curl jq  # jq f√ºr JSON-Verarbeitung (optional)
  script:
    - |
      # Gotify-Nachricht basierend auf den Job-Ergebnissen
      if [ -f "test-reports/failed-tests.txt" ] && [ -s "test-reports/failed-tests.txt" ]; then
        # ‚ùå Es gab Fehler
        MESSAGE="üö® *Nightly Tests FAILED* (${CI_COMMIT_SHORT_SHA})
        ‚û° <${CI_PIPELINE_URL}|View Pipeline>
        ‚û° <${CI_PROJECT_URL}/-/jobs/${CI_JOB_ID}/artifacts/file/test-report.md|Test Report>
        ‚û° <${CI_PROJECT_URL}/-/jobs/${CI_JOB_ID}/artifacts/file/broken-links.md|Broken Links>
        ‚û° *Failed Tests*: $(cat test-reports/failed-tests.txt | wc -l)"
        PRIORITY=5  # Hoch (5 = kritisch)
      else
        # ‚úÖ Alle Tests erfolgreich
        MESSAGE="‚úÖ *Nightly Tests PASSED* (${CI_COMMIT_SHORT_SHA})
        ‚û° <${CI_PIPELINE_URL}|View Pipeline>
        ‚û° <${CI_PROJECT_URL}/-/jobs/${CI_JOB_ID}/artifacts/file/test-report.md|Test Report>"
        PRIORITY=1  # Niedrig (1 = informativ)
      fi

      # Gotify-API aufrufen
      curl \
        -X POST \
        -H "Content-Type: application/json" \
        -H "X-Gotify-Key: ${GOTIFY_APP_TOKEN}" \
        -d "{
          \"message\": \"${MESSAGE}\",
          \"priority\": ${PRIORITY},
          \"title\": \"üåô Nightly Tests: ${CI_PROJECT_NAME}\",
          \"extras\": {
            \"client::display\": {
              \"contentType\": \"text/markdown\"
            },
            \"client::notification\": {
              \"click\": {
                \"url\": \"${CI_PIPELINE_URL}\"
              }
            }
          }
        }" \
        "${GOTIFY_URL}/message?token=${GOTIFY_APP_TOKEN}"

      echo "Gotify notification sent!"
  rules:
    - if: '$CI_PIPELINE_SOURCE == "schedule"'  # Nur bei geplanten Nightly-L√§ufen
    - if: '$CI_PIPELINE_SOURCE == "web"'       # Optional: Auch bei manuellem Trigger
  variables:
    GOTIFY_URL: "https://notify.hufschlaeger.net"  # CI/CD-Variable √ºberschreibt dies
    GOTIFY_APP_TOKEN: "$GOTIFY_APP_TOKEN"          # Wird aus GitLab-Variablen geladen
